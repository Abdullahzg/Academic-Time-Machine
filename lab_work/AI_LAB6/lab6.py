# -*- coding: utf-8 -*-
"""lab6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15TG7IOMWK8yjjV7BcAAYgcH3lKsTbIY3
"""

"""
Tic Tac Toe Player
"""

import copy
import math
import random
import sys


X = "X"
O = "O"
D = "D"
EMPTY = None
INFINITY = sys.maxsize
init_pos = (-1, -1)


def initial_state():
    """
    Returns starting state of the board.
    """
    return [[EMPTY, EMPTY, EMPTY],
            [EMPTY, EMPTY, EMPTY],
            [EMPTY, EMPTY, EMPTY]]
    
def draw_board(board):
    print("-------------")
    for i in range(3):
        print("| ", end="")
        for j in range(3):
            if board[i][j] == EMPTY:
                print(" ", end="")
            else:
                print(board[i][j], end="")
            print(" | ", end="")
        print()
        print("-------------")


def player(board):
    """
    Returns player who has the next turn on a board.
    """
    count = 0
    for i in board:
        for j in i:
            if j:
                count += 1
    if count % 2 != 0:
        return O
    return X


def actions(board):
    """
    Returns set of all possible actions (i, j) available on the board.
    """
    res = set()
    board_len = len(board)
    for i in range(board_len):
        for j in range(board_len):
            if board[i][j] == EMPTY:
                res.add((i, j))
    return res


def result(board, action):
    """
    Returns the board that results from making move (i, j) on the board.
    """
    curr_player = player(board)
    result_board = copy.deepcopy(board)
    (i, j) = action
    result_board[i][j] = curr_player
    return result_board


def get_horizontal_winner(board):
    # check horizontally
    winner_val = None
    board_len = len(board)
    for i in range(board_len):
        winner_val = board[i][0]
        for j in range(board_len):
            if board[i][j] != winner_val:
                winner_val = None
        if winner_val:
            return winner_val
    return winner_val


def get_vertical_winner(board):
    # check vertically
    winner_val = None
    board_len = len(board)
    for i in range(board_len):
        winner_val = board[0][i]
        for j in range(board_len):
            if board[j][i] != winner_val:
                winner_val = None
        if winner_val:
            return winner_val
    return winner_val


def get_diagonal_winner(board):
    # check diagonally
    winner_val = None
    board_len = len(board)
    winner_val = board[0][0]
    for i in range(board_len):
        if board[i][i] != winner_val:
            winner_val = None
    if winner_val:
        return winner_val

    winner_val = board[0][board_len - 1]
    for i in range(board_len):
        j = board_len - 1 - i
        if board[i][j] != winner_val:
            winner_val = None

    return winner_val


def getWinner(board):
    """
    Returns the winner of the game, if there is one.
    """
    winner_val = get_horizontal_winner(board) or get_vertical_winner(board) or get_diagonal_winner(board) or None
    return winner_val


def terminal(board):
    """
    Returns True if game is over, False otherwise.
    """
    if getWinner(board) != None:
        return True

    for i in board:
        for j in i:
            if j == EMPTY:
                return False
    return True

def utility(board):
    """
    Returns 1 if X has won the game, -1 if O has won, 0 otherwise.
    """
    winner_val = getWinner(board)
    if winner_val == X:
        return 1
    elif winner_val == O:
        return -1
    return 0


def alphaBetaPruning(board, depth, alpha, beta, turn):

  if terminal(board):
    util = utility(board)
    if util == 1:
      return [1, depth]
    elif util == -1:
      return [-1, depth]
    return [0, depth]

  if alpha[0] >= beta[0]:
    if turn == X:
      return alpha
    else:
      return beta 

  moves = actions(board)
  for move in moves:
    newBoard = result(board, move)
    if turn == X:
      newVal = alphaBetaPruning(newBoard, depth + 1, alpha, beta, O) 
      if (newVal[0] >= alpha[0] and newVal[1] < alpha[1]) or newVal[0] > alpha[0]:
        alpha = newVal
        if alpha[0] >= beta[0]: 
          return alpha
    else:
      newVal = alphaBetaPruning(newBoard, depth + 1, alpha, beta, X)
      if (newVal[0] <= beta[0] and newVal[1] < beta[1]) or newVal[0] < beta[0]:
        beta = newVal
        if alpha[0] >= beta[0]: 
          return beta

  if turn == X:
    return alpha
  else:
    return beta

def minimax(board):
  bestVal = [init_pos, INFINITY, INFINITY]
  alpha = [-INFINITY, INFINITY]
  beta = [INFINITY, INFINITY]

  moves = actions(board)
  turn = player(board)
  for move in moves:
    newBoard = result(board, move)
    val = alphaBetaPruning(newBoard, 0, alpha, beta, turn)
    if (val[0] <= bestVal[1] and val[1] < bestVal[2]) or val[0] < bestVal[1]:
      bestVal[0] = move
      bestVal[1] = val[0]
      bestVal[2] = val[1]

  return bestVal[0]
  
def play_game():
    board = initial_state()
    draw_board(board)
    print("Enter the row and column number. (X always plays first): ")
    row, col = map(int, input().split())
    board = result(board, (row, col))
    draw_board(board)
    while not terminal(board):
      action = minimax(board)
      print("AI made the move", action, "for player", player(board))
      board = result(board, action)
      draw_board(board)
    winner = getWinner(board)
    if (winner):
      print("Winner is ", winner)
    else:
      print("Its a draw.")
    
play_game()